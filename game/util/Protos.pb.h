// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protos.proto

#ifndef PROTOBUF_Protos_2eproto__INCLUDED
#define PROTOBUF_Protos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Protos_2eproto();
void protobuf_AssignDesc_Protos_2eproto();
void protobuf_ShutdownFile_Protos_2eproto();

class ServerEvent;
class ClientEvent;
class GameObject;
class ServerState;
class TestEvent;

enum GameObject_GameObjectType {
  GameObject_GameObjectType_PLAYER = 1,
  GameObject_GameObjectType_HAT = 2
};
bool GameObject_GameObjectType_IsValid(int value);
const GameObject_GameObjectType GameObject_GameObjectType_GameObjectType_MIN = GameObject_GameObjectType_PLAYER;
const GameObject_GameObjectType GameObject_GameObjectType_GameObjectType_MAX = GameObject_GameObjectType_HAT;
const int GameObject_GameObjectType_GameObjectType_ARRAYSIZE = GameObject_GameObjectType_GameObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameObject_GameObjectType_descriptor();
inline const ::std::string& GameObject_GameObjectType_Name(GameObject_GameObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameObject_GameObjectType_descriptor(), value);
}
inline bool GameObject_GameObjectType_Parse(
    const ::std::string& name, GameObject_GameObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameObject_GameObjectType>(
    GameObject_GameObjectType_descriptor(), name, value);
}
enum TestEvent_Type {
  TestEvent_Type_SPAWN = 1,
  TestEvent_Type_MOVE = 2,
  TestEvent_Type_ASSIGN = 3
};
bool TestEvent_Type_IsValid(int value);
const TestEvent_Type TestEvent_Type_Type_MIN = TestEvent_Type_SPAWN;
const TestEvent_Type TestEvent_Type_Type_MAX = TestEvent_Type_ASSIGN;
const int TestEvent_Type_Type_ARRAYSIZE = TestEvent_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TestEvent_Type_descriptor();
inline const ::std::string& TestEvent_Type_Name(TestEvent_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TestEvent_Type_descriptor(), value);
}
inline bool TestEvent_Type_Parse(
    const ::std::string& name, TestEvent_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestEvent_Type>(
    TestEvent_Type_descriptor(), name, value);
}
enum TypeClientEvent {
  MOVE = 1,
  SHOOT = 2,
  JUMP = 3
};
bool TypeClientEvent_IsValid(int value);
const TypeClientEvent TypeClientEvent_MIN = MOVE;
const TypeClientEvent TypeClientEvent_MAX = JUMP;
const int TypeClientEvent_ARRAYSIZE = TypeClientEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* TypeClientEvent_descriptor();
inline const ::std::string& TypeClientEvent_Name(TypeClientEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    TypeClientEvent_descriptor(), value);
}
inline bool TypeClientEvent_Parse(
    const ::std::string& name, TypeClientEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TypeClientEvent>(
    TypeClientEvent_descriptor(), name, value);
}
enum Direction {
  UP = 1,
  DOWN = 2,
  LEFT = 3,
  RIGHT = 4,
  FORWARD = 5,
  BACKWARD = 6
};
bool Direction_IsValid(int value);
const Direction Direction_MIN = UP;
const Direction Direction_MAX = BACKWARD;
const int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Direction_descriptor();
inline const ::std::string& Direction_Name(Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Direction_descriptor(), value);
}
inline bool Direction_Parse(
    const ::std::string& name, Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
// ===================================================================

class ServerEvent : public ::google::protobuf::Message {
 public:
  ServerEvent();
  virtual ~ServerEvent();

  ServerEvent(const ServerEvent& from);

  inline ServerEvent& operator=(const ServerEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerEvent& default_instance();

  void Swap(ServerEvent* other);

  // implements Message ----------------------------------------------

  ServerEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerEvent& from);
  void MergeFrom(const ServerEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protos.ServerEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_Protos_2eproto();
  friend void protobuf_AssignDesc_Protos_2eproto();
  friend void protobuf_ShutdownFile_Protos_2eproto();

  void InitAsDefaultInstance();
  static ServerEvent* default_instance_;
};
// -------------------------------------------------------------------

class ClientEvent : public ::google::protobuf::Message {
 public:
  ClientEvent();
  virtual ~ClientEvent();

  ClientEvent(const ClientEvent& from);

  inline ClientEvent& operator=(const ClientEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientEvent& default_instance();

  void Swap(ClientEvent* other);

  // implements Message ----------------------------------------------

  ClientEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientEvent& from);
  void MergeFrom(const ClientEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .protos.TypeClientEvent type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::protos::TypeClientEvent type() const;
  inline void set_type(::protos::TypeClientEvent value);

  // optional .protos.Direction direction = 3;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 3;
  inline ::protos::Direction direction() const;
  inline void set_direction(::protos::Direction value);

  // @@protoc_insertion_point(class_scope:protos.ClientEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  int type_;
  int direction_;
  friend void  protobuf_AddDesc_Protos_2eproto();
  friend void protobuf_AssignDesc_Protos_2eproto();
  friend void protobuf_ShutdownFile_Protos_2eproto();

  void InitAsDefaultInstance();
  static ClientEvent* default_instance_;
};
// -------------------------------------------------------------------

class GameObject : public ::google::protobuf::Message {
 public:
  GameObject();
  virtual ~GameObject();

  GameObject(const GameObject& from);

  inline GameObject& operator=(const GameObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameObject& default_instance();

  void Swap(GameObject* other);

  // implements Message ----------------------------------------------

  GameObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameObject& from);
  void MergeFrom(const GameObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameObject_GameObjectType GameObjectType;
  static const GameObjectType PLAYER = GameObject_GameObjectType_PLAYER;
  static const GameObjectType HAT = GameObject_GameObjectType_HAT;
  static inline bool GameObjectType_IsValid(int value) {
    return GameObject_GameObjectType_IsValid(value);
  }
  static const GameObjectType GameObjectType_MIN =
    GameObject_GameObjectType_GameObjectType_MIN;
  static const GameObjectType GameObjectType_MAX =
    GameObject_GameObjectType_GameObjectType_MAX;
  static const int GameObjectType_ARRAYSIZE =
    GameObject_GameObjectType_GameObjectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GameObjectType_descriptor() {
    return GameObject_GameObjectType_descriptor();
  }
  static inline const ::std::string& GameObjectType_Name(GameObjectType value) {
    return GameObject_GameObjectType_Name(value);
  }
  static inline bool GameObjectType_Parse(const ::std::string& name,
      GameObjectType* value) {
    return GameObject_GameObjectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated double matrix = 2;
  inline int matrix_size() const;
  inline void clear_matrix();
  static const int kMatrixFieldNumber = 2;
  inline double matrix(int index) const;
  inline void set_matrix(int index, double value);
  inline void add_matrix(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      matrix() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_matrix();

  // optional .protos.GameObject.GameObjectType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::protos::GameObject_GameObjectType type() const;
  inline void set_type(::protos::GameObject_GameObjectType value);

  // @@protoc_insertion_point(class_scope:protos.GameObject)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > matrix_;
  ::google::protobuf::int32 id_;
  int type_;
  friend void  protobuf_AddDesc_Protos_2eproto();
  friend void protobuf_AssignDesc_Protos_2eproto();
  friend void protobuf_ShutdownFile_Protos_2eproto();

  void InitAsDefaultInstance();
  static GameObject* default_instance_;
};
// -------------------------------------------------------------------

class ServerState : public ::google::protobuf::Message {
 public:
  ServerState();
  virtual ~ServerState();

  ServerState(const ServerState& from);

  inline ServerState& operator=(const ServerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerState& default_instance();

  void Swap(ServerState* other);

  // implements Message ----------------------------------------------

  ServerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerState& from);
  void MergeFrom(const ServerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .protos.GameObject objects = 2;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 2;
  inline const ::protos::GameObject& objects(int index) const;
  inline ::protos::GameObject* mutable_objects(int index);
  inline ::protos::GameObject* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::GameObject >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::GameObject >*
      mutable_objects();

  // repeated .protos.ServerEvent events = 3;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 3;
  inline const ::protos::ServerEvent& events(int index) const;
  inline ::protos::ServerEvent* mutable_events(int index);
  inline ::protos::ServerEvent* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::ServerEvent >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::ServerEvent >*
      mutable_events();

  // @@protoc_insertion_point(class_scope:protos.ServerState)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protos::GameObject > objects_;
  ::google::protobuf::RepeatedPtrField< ::protos::ServerEvent > events_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_Protos_2eproto();
  friend void protobuf_AssignDesc_Protos_2eproto();
  friend void protobuf_ShutdownFile_Protos_2eproto();

  void InitAsDefaultInstance();
  static ServerState* default_instance_;
};
// -------------------------------------------------------------------

class TestEvent : public ::google::protobuf::Message {
 public:
  TestEvent();
  virtual ~TestEvent();

  TestEvent(const TestEvent& from);

  inline TestEvent& operator=(const TestEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestEvent& default_instance();

  void Swap(TestEvent* other);

  // implements Message ----------------------------------------------

  TestEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestEvent& from);
  void MergeFrom(const TestEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TestEvent_Type Type;
  static const Type SPAWN = TestEvent_Type_SPAWN;
  static const Type MOVE = TestEvent_Type_MOVE;
  static const Type ASSIGN = TestEvent_Type_ASSIGN;
  static inline bool Type_IsValid(int value) {
    return TestEvent_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TestEvent_Type_Type_MIN;
  static const Type Type_MAX =
    TestEvent_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TestEvent_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TestEvent_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TestEvent_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TestEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .protos.TestEvent.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::protos::TestEvent_Type type() const;
  inline void set_type(::protos::TestEvent_Type value);

  // repeated .protos.GameObject gameObject = 3;
  inline int gameobject_size() const;
  inline void clear_gameobject();
  static const int kGameObjectFieldNumber = 3;
  inline const ::protos::GameObject& gameobject(int index) const;
  inline ::protos::GameObject* mutable_gameobject(int index);
  inline ::protos::GameObject* add_gameobject();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::GameObject >&
      gameobject() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::GameObject >*
      mutable_gameobject();

  // optional int32 action = 4;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 4;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // optional int32 keyPress = 5;
  inline bool has_keypress() const;
  inline void clear_keypress();
  static const int kKeyPressFieldNumber = 5;
  inline ::google::protobuf::int32 keypress() const;
  inline void set_keypress(::google::protobuf::int32 value);

  // optional int32 clientID = 6;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIDFieldNumber = 6;
  inline ::google::protobuf::int32 clientid() const;
  inline void set_clientid(::google::protobuf::int32 value);

  // optional .protos.Direction direction = 7;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 7;
  inline ::protos::Direction direction() const;
  inline void set_direction(::protos::Direction value);

  // @@protoc_insertion_point(class_scope:protos.TestEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_keypress();
  inline void clear_has_keypress();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::protos::GameObject > gameobject_;
  ::google::protobuf::int32 action_;
  ::google::protobuf::int32 keypress_;
  ::google::protobuf::int32 clientid_;
  int direction_;
  friend void  protobuf_AddDesc_Protos_2eproto();
  friend void protobuf_AssignDesc_Protos_2eproto();
  friend void protobuf_ShutdownFile_Protos_2eproto();

  void InitAsDefaultInstance();
  static TestEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// ServerEvent

// optional int32 id = 1;
inline bool ServerEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerEvent::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ServerEvent::id() const {
  // @@protoc_insertion_point(field_get:protos.ServerEvent.id)
  return id_;
}
inline void ServerEvent::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protos.ServerEvent.id)
}

// -------------------------------------------------------------------

// ClientEvent

// optional int32 id = 1;
inline bool ClientEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientEvent::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ClientEvent::id() const {
  // @@protoc_insertion_point(field_get:protos.ClientEvent.id)
  return id_;
}
inline void ClientEvent::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protos.ClientEvent.id)
}

// optional .protos.TypeClientEvent type = 2;
inline bool ClientEvent::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientEvent::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientEvent::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::protos::TypeClientEvent ClientEvent::type() const {
  // @@protoc_insertion_point(field_get:protos.ClientEvent.type)
  return static_cast< ::protos::TypeClientEvent >(type_);
}
inline void ClientEvent::set_type(::protos::TypeClientEvent value) {
  assert(::protos::TypeClientEvent_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protos.ClientEvent.type)
}

// optional .protos.Direction direction = 3;
inline bool ClientEvent::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientEvent::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientEvent::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientEvent::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::protos::Direction ClientEvent::direction() const {
  // @@protoc_insertion_point(field_get:protos.ClientEvent.direction)
  return static_cast< ::protos::Direction >(direction_);
}
inline void ClientEvent::set_direction(::protos::Direction value) {
  assert(::protos::Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:protos.ClientEvent.direction)
}

// -------------------------------------------------------------------

// GameObject

// optional int32 id = 1;
inline bool GameObject::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameObject::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameObject::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameObject::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GameObject::id() const {
  // @@protoc_insertion_point(field_get:protos.GameObject.id)
  return id_;
}
inline void GameObject::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protos.GameObject.id)
}

// repeated double matrix = 2;
inline int GameObject::matrix_size() const {
  return matrix_.size();
}
inline void GameObject::clear_matrix() {
  matrix_.Clear();
}
inline double GameObject::matrix(int index) const {
  // @@protoc_insertion_point(field_get:protos.GameObject.matrix)
  return matrix_.Get(index);
}
inline void GameObject::set_matrix(int index, double value) {
  matrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:protos.GameObject.matrix)
}
inline void GameObject::add_matrix(double value) {
  matrix_.Add(value);
  // @@protoc_insertion_point(field_add:protos.GameObject.matrix)
}
inline const ::google::protobuf::RepeatedField< double >&
GameObject::matrix() const {
  // @@protoc_insertion_point(field_list:protos.GameObject.matrix)
  return matrix_;
}
inline ::google::protobuf::RepeatedField< double >*
GameObject::mutable_matrix() {
  // @@protoc_insertion_point(field_mutable_list:protos.GameObject.matrix)
  return &matrix_;
}

// optional .protos.GameObject.GameObjectType type = 3;
inline bool GameObject::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameObject::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameObject::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameObject::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::protos::GameObject_GameObjectType GameObject::type() const {
  // @@protoc_insertion_point(field_get:protos.GameObject.type)
  return static_cast< ::protos::GameObject_GameObjectType >(type_);
}
inline void GameObject::set_type(::protos::GameObject_GameObjectType value) {
  assert(::protos::GameObject_GameObjectType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protos.GameObject.type)
}

// -------------------------------------------------------------------

// ServerState

// optional int32 id = 1;
inline bool ServerState::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerState::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerState::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerState::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ServerState::id() const {
  // @@protoc_insertion_point(field_get:protos.ServerState.id)
  return id_;
}
inline void ServerState::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protos.ServerState.id)
}

// repeated .protos.GameObject objects = 2;
inline int ServerState::objects_size() const {
  return objects_.size();
}
inline void ServerState::clear_objects() {
  objects_.Clear();
}
inline const ::protos::GameObject& ServerState::objects(int index) const {
  // @@protoc_insertion_point(field_get:protos.ServerState.objects)
  return objects_.Get(index);
}
inline ::protos::GameObject* ServerState::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:protos.ServerState.objects)
  return objects_.Mutable(index);
}
inline ::protos::GameObject* ServerState::add_objects() {
  // @@protoc_insertion_point(field_add:protos.ServerState.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::GameObject >&
ServerState::objects() const {
  // @@protoc_insertion_point(field_list:protos.ServerState.objects)
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::GameObject >*
ServerState::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:protos.ServerState.objects)
  return &objects_;
}

// repeated .protos.ServerEvent events = 3;
inline int ServerState::events_size() const {
  return events_.size();
}
inline void ServerState::clear_events() {
  events_.Clear();
}
inline const ::protos::ServerEvent& ServerState::events(int index) const {
  // @@protoc_insertion_point(field_get:protos.ServerState.events)
  return events_.Get(index);
}
inline ::protos::ServerEvent* ServerState::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:protos.ServerState.events)
  return events_.Mutable(index);
}
inline ::protos::ServerEvent* ServerState::add_events() {
  // @@protoc_insertion_point(field_add:protos.ServerState.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::ServerEvent >&
ServerState::events() const {
  // @@protoc_insertion_point(field_list:protos.ServerState.events)
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::ServerEvent >*
ServerState::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:protos.ServerState.events)
  return &events_;
}

// -------------------------------------------------------------------

// TestEvent

// optional int32 id = 1;
inline bool TestEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestEvent::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TestEvent::id() const {
  // @@protoc_insertion_point(field_get:protos.TestEvent.id)
  return id_;
}
inline void TestEvent::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protos.TestEvent.id)
}

// optional .protos.TestEvent.Type type = 2;
inline bool TestEvent::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestEvent::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestEvent::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::protos::TestEvent_Type TestEvent::type() const {
  // @@protoc_insertion_point(field_get:protos.TestEvent.type)
  return static_cast< ::protos::TestEvent_Type >(type_);
}
inline void TestEvent::set_type(::protos::TestEvent_Type value) {
  assert(::protos::TestEvent_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protos.TestEvent.type)
}

// repeated .protos.GameObject gameObject = 3;
inline int TestEvent::gameobject_size() const {
  return gameobject_.size();
}
inline void TestEvent::clear_gameobject() {
  gameobject_.Clear();
}
inline const ::protos::GameObject& TestEvent::gameobject(int index) const {
  // @@protoc_insertion_point(field_get:protos.TestEvent.gameObject)
  return gameobject_.Get(index);
}
inline ::protos::GameObject* TestEvent::mutable_gameobject(int index) {
  // @@protoc_insertion_point(field_mutable:protos.TestEvent.gameObject)
  return gameobject_.Mutable(index);
}
inline ::protos::GameObject* TestEvent::add_gameobject() {
  // @@protoc_insertion_point(field_add:protos.TestEvent.gameObject)
  return gameobject_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::GameObject >&
TestEvent::gameobject() const {
  // @@protoc_insertion_point(field_list:protos.TestEvent.gameObject)
  return gameobject_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::GameObject >*
TestEvent::mutable_gameobject() {
  // @@protoc_insertion_point(field_mutable_list:protos.TestEvent.gameObject)
  return &gameobject_;
}

// optional int32 action = 4;
inline bool TestEvent::has_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestEvent::set_has_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestEvent::clear_has_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestEvent::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 TestEvent::action() const {
  // @@protoc_insertion_point(field_get:protos.TestEvent.action)
  return action_;
}
inline void TestEvent::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:protos.TestEvent.action)
}

// optional int32 keyPress = 5;
inline bool TestEvent::has_keypress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestEvent::set_has_keypress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestEvent::clear_has_keypress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestEvent::clear_keypress() {
  keypress_ = 0;
  clear_has_keypress();
}
inline ::google::protobuf::int32 TestEvent::keypress() const {
  // @@protoc_insertion_point(field_get:protos.TestEvent.keyPress)
  return keypress_;
}
inline void TestEvent::set_keypress(::google::protobuf::int32 value) {
  set_has_keypress();
  keypress_ = value;
  // @@protoc_insertion_point(field_set:protos.TestEvent.keyPress)
}

// optional int32 clientID = 6;
inline bool TestEvent::has_clientid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TestEvent::set_has_clientid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TestEvent::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TestEvent::clear_clientid() {
  clientid_ = 0;
  clear_has_clientid();
}
inline ::google::protobuf::int32 TestEvent::clientid() const {
  // @@protoc_insertion_point(field_get:protos.TestEvent.clientID)
  return clientid_;
}
inline void TestEvent::set_clientid(::google::protobuf::int32 value) {
  set_has_clientid();
  clientid_ = value;
  // @@protoc_insertion_point(field_set:protos.TestEvent.clientID)
}

// optional .protos.Direction direction = 7;
inline bool TestEvent::has_direction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TestEvent::set_has_direction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TestEvent::clear_has_direction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TestEvent::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::protos::Direction TestEvent::direction() const {
  // @@protoc_insertion_point(field_get:protos.TestEvent.direction)
  return static_cast< ::protos::Direction >(direction_);
}
inline void TestEvent::set_direction(::protos::Direction value) {
  assert(::protos::Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:protos.TestEvent.direction)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protos::GameObject_GameObjectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protos::GameObject_GameObjectType>() {
  return ::protos::GameObject_GameObjectType_descriptor();
}
template <> struct is_proto_enum< ::protos::TestEvent_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protos::TestEvent_Type>() {
  return ::protos::TestEvent_Type_descriptor();
}
template <> struct is_proto_enum< ::protos::TypeClientEvent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protos::TypeClientEvent>() {
  return ::protos::TypeClientEvent_descriptor();
}
template <> struct is_proto_enum< ::protos::Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protos::Direction>() {
  return ::protos::Direction_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Protos_2eproto__INCLUDED
